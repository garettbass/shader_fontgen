<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>fontpage</title>
  </head>
  <body>

    <script type="text/javascript">
      symbols = ["⏮⏪⏴⏺⏹⏵⏸⏩⏭♩♪♫♬♭♮♯",
        "←↑→↓↔↕↖↗↘↙↺↻★☻  ",
        "αβγδεθλμξπρστφψω",
        "ΓΔΘΛΠΣΦΨΩ∞ƒ∘∫∂∇√"];
        // "αβγδεθλμξπρστφψω"
        // "ΓΔΘΛΠΣΦΨΩ"
        // "∇√∞∘∫"
        // "⏮⏪⏴⏺⏹⏸⏵⏩⏭"
        // "📷📹📽🕨🕪🖮"
        // "☀☁☂☃⇦⇧⇨⇩"
        // "♡♥"


      downCount = 2;
      cellSize = 256 | 0;
      texSize = 4096 | 0;

      tileCount = (texSize / cellSize) | 0;
      bufferF = new Float32Array(texSize * texSize);
      widthF = texSize;
      heightF = texSize;
      var myImageData;
      var newImg;
      function createTextCanvas(color, font) {
        var canvas = document.createElement('canvas');
        // var canvasSmall = document.createElement('canvasSmall');
        var ctx = canvas.getContext('2d');
        // var ctxSmall = canvasSmall.getContext('2d');
        var fontStrA = 'bold ' + ((cellSize * 0.9218) + 'px ') + (font || 'Helvetica');
        var fontStrB = 'bold ' + ((cellSize * 0.78125) + 'px ') + (font || 'Noto mono');
        var fontStrC = '' + ((cellSize - 14) + 'px ') + (font || 'Symbola');
        var fontStrD = '' + ((cellSize - 14) + 'px ') + (font || 'Apple Symbols');
        canvas.width = texSize;
        canvas.height = texSize;
        canvas.style.backgroundColor = 'rgba(100, 40, 60, 1.0)';
        ctx.fillRect(0, 0, texSize, texSize);
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.fillRect((x+1)*cellSize-1,0,1,canvas.width);
            ctx.fillRect(0, (y+1)*cellSize-1, canvas.width, 1);
          }
        }
        ctx.fillStyle = color || 'white';
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.font = fontStrB;
            var text = String.fromCharCode(x + y * tileCount)
            if (y <= 1) text = symbols[y][x];
            if ((y==8) || (y==9)) text = symbols[y-6][x];
            if ((y==1) && (x==13)) ctx.font = fontStrD;
            if ((y==1) && (x==14)) text = "🕨";
            if ((y==1) && (x==15)) text = "🕪";
            var xoff = cellSize * 0.2656 //17;
            var posx = xoff + x * cellSize;
            var posy = y * cellSize + cellSize / 2 + cellSize / 3.75;
            if ((y==1) && (x<10)) {
              ctx.font = fontStrA;
              posy += cellSize * 0.0625;
              if (x == 4) posy -= cellSize * 0.09375;
            }
            if ((y==0) && (x<9)) {
              ctx.font = fontStrC;
              posy -= cellSize * 0.046875;
              // if (x == 4) posy -= 6;
            }
            // if ((y==9) && (x >= 14)) {
            //   // For hearts
            //   ctx.font = fontStrA;
            //   posx -= cellSize * 0.25;
            //   posy += cellSize * 0.0625;
            // }
            mw = ctx.measureText(text).width;
//            if (mw + xoff >= cellSize) posx -= (mw + xoff) - cellSize + 3;
            if (y <= 1) posx = (cellSize-mw) / 2 + x * cellSize;  // Center symbols
//            if ((x == 15) && (y == 5)) posy -= 6;     // HACK FOR UNDERSCORE!!!!
//            if ((x == 0) && (y == 9)) posy -= 2;     // HACK FOR symbol
//            if ((x == 10) && (y == 9)) posy += 6;     // HACK FOR symbol
//            if (y == 0) posy += 4;
            ctx.fillText(text, posx, posy);
          }
        }

        myImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        //blueComponent = myImageData.data[((50*(myImageData.width*4)) + (200*4)) + 2];
        //myImageData.data[((2*(myImageData.width*4)) + (2*4)) + 2] = 255;
        for (var y = 0; y < tileCount; y++) {
          console.log("Row " + y);
          for (var x = 0; x < tileCount; x++) {
            console.log("Col " + x);
            var borderPixels = FindBorderPixels(myImageData, x, y);
            FillDistance(myImageData, borderPixels, x, y);
            // for (var dy = 0; dy < cellSize; dy++) {
            //   for (var dx = 0; dx < cellSize; dx++) {
            //     var distAndGrad = NearestPixelDistance(myImageData, x * cellSize + dx, y * cellSize + dy);
            //     var dist = distAndGrad[0]
            //     if (texSize == 2048) dist *= 0.5;
            //     if (texSize == 4096) dist *= 0.25;
            //     SetPixelF(x * cellSize + dx, y * cellSize + dy, dist);
            //     // dist *= 4.0;  // Scale for more precision in 8 bit range.
            //     // dist = (dist) | 0;
            //     // dist += 128;
            //     // dist = Math.min(255, Math.max(0, dist));
            //     // SetPixelA(myImageData, x * cellSize + dx, y * cellSize + dy, dist);
            //     // var gradX = distAndGrad[1] | 0;
            //     // var gradY = distAndGrad[2] | 0;
            //     // gradX /= 2;
            //     // gradY /= 2;
            //     // gradX += 128;
            //     // gradY += 128;
            //     // gradX = Math.min(255, Math.max(0, gradX));
            //     // gradY = Math.min(255, Math.max(0, gradY));
            //     // SetPixelG(myImageData, x * cellSize + dx, y * cellSize + dy, gradX);
            //     // SetPixelB(myImageData, x * cellSize + dx, y * cellSize + dy, gradY);
            //   }
            // }
          }
        }

        canvas.width = texSize >> downCount;
        canvas.height = texSize >> downCount;
        newImg = myImageData;
        for (var i = 0; i < downCount; i++) {
          DownSampleF();
          newImg = DownSampleR(newImg, ctx);
        }
        //myImageData.data.set(newImg);
        CopyInToA(newImg);
        for (var y = 0; y < newImg.height; y++) {
          for (var x = 0; x < newImg.width; x++) {
            var grad = CalcGradF(x, y);
            var gradScale = 64.0;
            var gradX = (grad[0] * gradScale) | 0;
            var gradY = (grad[1] * gradScale) | 0;
            // gradX /= 2;
            // gradY /= 2;
            gradX += 128;
            gradY += 128;
            gradX = Math.min(255, Math.max(0, gradX));
            gradY = Math.min(255, Math.max(0, gradY));
            SetPixelG(newImg, x, y, gradX);
            SetPixelB(newImg, x, y, gradY);
          }
        }

        ctx.putImageData(myImageData, 0, 0);
        ctx.putImageData(newImg, 0, 0);
        
        return canvas;
      }

      function IsBorderPixel(imageData, x, y) {
        var pix00 = GetPixelRTile(imageData, x, y, x, y)
        var pixP0 = GetPixelRTile(imageData, x, y, x + 1, y)
        var pixN0 = GetPixelRTile(imageData, x, y, x - 1, y)
        var pix0P = GetPixelRTile(imageData, x, y, x, y + 1)
        var pix0N = GetPixelRTile(imageData, x, y, x, y - 1)
        var on = pix00 >= 128;
        if ((pixP0 >= 128) != on) return true;
        if ((pixN0 >= 128) != on) return true;
        if ((pix0P >= 128) != on) return true;
        if ((pix0N >= 128) != on) return true;
        return false;
      }
      function FindBorderPixels(imageData, tx, ty) {
        var borderPixels = new Set();
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var posx = tx * cellSize + dx;
            var posy = ty * cellSize + dy;
            var border = IsBorderPixel(imageData, posx, posy);
            if (border) borderPixels.add((posx + posy * imageData.width) | 0)
          }
        }
        return borderPixels;
      }
      function FillDistance(imageData, borderPixels, tx, ty) {
        // Clear cell to max value.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            SetPixelF(pixx, pixy, cellSize);
          }
        }
        // For every border pixel, draw a cone of distance from it. Only draw if smaller than existing
        // pixels so we get minimum distance everywhere.
        for (let pixel of borderPixels) {
          var posx = (pixel % imageData.width) | 0;
          var posy = (pixel / imageData.width) | 0;
          //SetPixelB(imageData, posx, posy, 255);
          var sign = 1;
          if (GetPixelR(imageData, posx, posy) >= 128) sign = -sign;
          if (sign < 0) {
            for (var dy = 0; dy < cellSize; dy++) {
              for (var dx = 0; dx < cellSize; dx++) {
                var pixx = tx * cellSize + dx;
                var pixy = ty * cellSize + dy;
                var currentSign = GetPixelR(imageData, pixx, pixy) >= 128 ? -1 : 1;
                if (currentSign != sign) {
                  var distSquared = Math.sqrt((posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy));
                  distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                  var current = GetPixelF(pixx, pixy);
                  if (distSquared < current) {
                    SetPixelF(pixx, pixy, distSquared);
                  }
                }
              }
            }
          }
          if (sign > 0) {
            for (var dy = 0; dy < cellSize; dy++) {
              for (var dx = 0; dx < cellSize; dx++) {
                var pixx = tx * cellSize + dx;
                var pixy = ty * cellSize + dy;
                var currentSign = GetPixelR(imageData, pixx, pixy) >= 128 ? -1 : 1;
                if (currentSign != sign) {
                  var distSquared = Math.sqrt((posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy));
                  distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                  var current = GetPixelF(pixx, pixy);
                  if (distSquared < current) {
                    SetPixelF(pixx, pixy, distSquared);
                  }
                }
              }
            }
          }
        }
        var scaler = 1.0 / (Math.pow(2, downCount))
        // Negate inside of letter for signed distance function.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            var currentSign = GetPixelR(imageData, pixx, pixy) >= 128 ? -1 : 1;
            var current = GetPixelF(pixx , pixy);
            current *= scaler;
            if (currentSign == -1) {
              SetPixelF(pixx, pixy, -current);
            } else {
              SetPixelF(pixx, pixy, current);
            }
          }
        }
      }

      function DownSampleR(imageData, ctx) {
        var w2 = (imageData.width / 2) | 0;
        var h2 = (imageData.height / 2) | 0;
        // var buf2 = new Uint8ClampedArray(w2 * h2);
        var buf2 = ctx.createImageData(w2, h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelR(imageData, x * 2, y * 2);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelR(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelR(buf2, x, y, f0 | 0);
            SetPixelA(buf2,x,y,255);
          }
        }
        return buf2;
      }
      function DownSampleF() {
        var w2 = (widthF / 2) | 0;
        var h2 = (heightF / 2) | 0;
        var buf2 = new Float32Array(w2 * h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelF(x * 2, y * 2);
            f0 += GetPixelF(x * 2 + 1, y * 2);
            f0 += GetPixelF(x * 2, y * 2 + 1);
            f0 += GetPixelF(x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            buf2[y*w2 + x] = f0;
          }
        }
        bufferF = buf2;
        widthF = w2;
        heightF = h2;
      }
      function CopyInToA(imageData) {
        for (var y = 0; y < heightF; y++) {
          for (var x = 0; x < widthF; x++) {
            var pix = GetPixelF(x, y);
            pix *= 4.0;
            pix = pix | 0;
            pix += 128;
            pix = Math.min(255, Math.max(0, pix));
            SetPixelA(imageData, x, y, pix);
          }
        }
      }

      function CalcGradF(x, y) {
        var pix00 = GetPixelFTile(x, y, x, y)
        var pixP0 = GetPixelFTile(x, y, x + 1, y)
        var pixN0 = GetPixelFTile(x, y, x - 1, y)
        var pix0P = GetPixelFTile(x, y, x, y + 1)
        var pix0N = GetPixelFTile(x, y, x, y - 1)
        var gradX = 0;
        var gradY = 0;
        gradX = pixN0 - pixP0;
        gradY = pix0N - pix0P;
        return [-gradX, -gradY];
      }
      function CalcGrad(imageData, x, y) {
        var pix00 = GetPixelR(imageData, x, y)
        var pixP0 = GetPixelR(imageData, x + 1, y)
        var pixN0 = GetPixelR(imageData, x - 1, y)
        var pix0P = GetPixelR(imageData, x, y + 1)
        var pix0N = GetPixelR(imageData, x, y - 1)
        /*var pixPP = GetPixelR(imageData, x + 1, y + 1)
        var pixPN = GetPixelR(imageData, x + 1, y - 1)
        var pixNN = GetPixelR(imageData, x - 1, y - 1)
        var pixNP = GetPixelR(imageData, x - 1, y + 1)
        var mask = 0;
        if (pix00 >= 128) mask |= 1 << 8;
        if (pixP0 >= 128) mask |= 1 << 7;
        if (pixN0 >= 128) mask |= 1 << 6;
        if (pix0P >= 128) mask |= 1 << 5;
        if (pix0N >= 128) mask |= 1 << 4;
        if (pixPP >= 128) mask |= 1 << 3;
        if (pixPN >= 128) mask |= 1 << 2;
        if (pixNN >= 128) mask |= 1 << 1;
        if (pixNP >= 128) mask |= 1;
        var pixUL = (pix00 + pixN0 + pixNN + pix0N) * 0.25*/
        var gradX = 0;
        var gradY = 0;
        gradX = pixN0 - pixP0;
        gradY = pix0N - pix0P;
        // gradX = pixN0 - pix00;
        // gradX += pix00 - pixP0;
        // gradX *= 0.5;
        // gradY = pix0N - pix00;
        // gradY += pix00 - pix0P;
        // gradY *= 0.5;
        return [gradX, gradY];
      }

      function NearestPixelDistance(imageData, x, y) {
        x = x | 0;
        y = y | 0;
        var sign = 1;
        if (GetPixelR(imageData, x, y) >= 128) sign = -sign;

        var bestDist = cellSize * 1.414;
        var minDistSquaredPos = bestDist * bestDist;
        var nearestGradX = 0;
        var nearestGradY = 0;
        var grad = {x:0, y:0};
        for (var rad = 0; rad < cellSize; rad++) {
          for (var dx = -rad; dx <= rad; dx++) {
            var posx = (x + dx);
            // if (posx < Math.floor(x / cellSize) * cellSize) continue;
            // if (posx > Math.floor(x / cellSize) * cellSize + cellSize) continue;
            var posy = (y - rad);
            if ((((posx / cellSize) | 0) == ((x / cellSize) | 0)) && (((posy / cellSize) | 0) == ((y / cellSize) | 0))) {
              if (GetPixelR(imageData, posx, posy)*sign >= 128*sign) {
                var distSquared = (posx - x) * (posx - x) + (posy - y) * (posy - y);
                if (distSquared < minDistSquaredPos) {
                  minDistSquaredPos = distSquared;
                  var dist = Math.sqrt(distSquared);
                  dist += sign * 0.5 - 0.5;
                  dist *= sign;
                  bestDist = dist;
                }
              }
            }
            posy = y + rad;
            if ((((posx / cellSize) | 0) == ((x / cellSize) | 0)) && (((posy / cellSize) | 0) == ((y / cellSize) | 0))) {
              if (GetPixelR(imageData, posx, posy)*sign >= 128*sign) {
                var distSquared = (posx - x) * (posx - x) + (posy - y) * (posy - y);
                if (distSquared < minDistSquaredPos) {
                  minDistSquaredPos = distSquared;
                  var dist = Math.sqrt(distSquared);
                  dist += sign * 0.5 - 0.5;
                  dist *= sign;
                  bestDist = dist;
                }
              }
            }
          }
          for (var dy = -rad; dy <= rad; dy++) {
            var posx = x - rad;
            var posy = y + dy;
            // if (posy < Math.floor(y / cellSize) * cellSize) continue;
            // if (posy > Math.floor(y / cellSize) * cellSize + cellSize) continue;
            if ((((posx / cellSize) | 0) == ((x / cellSize) | 0)) && (((posy / cellSize) | 0) == ((y / cellSize) | 0))) {
              if (GetPixelR(imageData, posx, posy)*sign >= 128*sign) {
                var distSquared = (posx - x) * (posx - x) + (posy - y) * (posy - y);
                if (distSquared < minDistSquaredPos) {
                  minDistSquaredPos = distSquared;
                  var dist = Math.sqrt(distSquared);
                  dist += sign * 0.5 - 0.5;
                  dist *= sign;
                  bestDist = dist;
                }
              }
            }
            posx = x + rad;
            if ((((posx / cellSize) | 0) == ((x / cellSize) | 0)) && (((posy / cellSize) | 0) == ((y / cellSize) | 0))) {
              if (GetPixelR(imageData, posx, posy)*sign >= 128*sign) {
                var distSquared = (posx - x) * (posx - x) + (posy - y) * (posy - y);
                if (distSquared < minDistSquaredPos) {
                  minDistSquaredPos = distSquared;
                  var dist = Math.sqrt(distSquared);
                  dist += sign * 0.5 - 0.5;
                  dist *= sign;
                  bestDist = dist;
                }
              }
            }
          }
          // Quit if rad > sqrt(2) rounded up times minDist
          if (rad > Math.sqrt(minDistSquaredPos) * 1.5) break;
        }
        // make the border exactly at the zero crossing.
        bestDist -= 0.5;
        return [bestDist, grad[0], grad[1]];
      }
      function InRange(imageData, x, y) {
        if (x < 0) return false;
        if (y < 0) return false;
        if (x >= imageData.width) return false;
        if (y >= imageData.height) return false;
        return true;
      }
      function GetPixelR(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }
      function GetPixelG(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 1];
      }
      function GetPixelB(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 2];
      }
      function SetPixelR(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 0] = pix;
      }
      function SetPixelG(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 1] = pix;
      }
      function SetPixelB(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 2] = pix;
      }
      function SetPixelA(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 3] = pix;
      }
      function SetPixelF(x, y, pix) {
        bufferF[y*widthF + x] = pix;
      }
      function GetPixelF(x, y) {
        if (x < 0) return 0.0;
        if (y < 0) return 0.0;
        if (x >= widthF) return 0.0;
        if (y >= heightF) return 0.0;
        return bufferF[y*widthF + x];
      }
      function GetPixelFTile(tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return bufferF[y*widthF + x];
      }
      function GetPixelRTile(imageData, tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }

      function GenChar() {
        canvas = createTextCanvas('white', undefined);
        document.body.appendChild(canvas);

        canvas.onclick = function(e) {
          e = e || window.event
          var rect = canvas.getBoundingClientRect();
          var mousex = e.clientX - rect.left;
          var mousey = e.clientY - rect.top;
          var pixG = GetPixelG(newImg, mousex, mousey);
          var pixB = GetPixelB(newImg, mousex, mousey);
          console.log('Green: ' + pixG + "   Blue: " + pixB);
        }
      }

      function autorun()
      {
        GenChar();
        document.body.style.background = "#888";
      }
      if (document.addEventListener) document.addEventListener("DOMContentLoaded", autorun, false);
      else if (document.attachEvent) document.attachEvent("onreadystatechange", autorun);
      else window.onload = autorun;
    </script>
  </body>
</html>
