<!--
License CC0 - http://creativecommons.org/publicdomain/zero/1.0/
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.

^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.
-Otavio Good
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>fontpage</title>
  </head>
  <body>

    <script type="text/javascript">
      symbols = ["⏮⏪⏴⏺⏹⏵⏸⏩⏭♩♪♫♬♭♮♯",
        "←↑→↓↔↕↖↗↘↙↺↻★☻  ",
        "αβγδεθλμξπρστφψω",
        "ΓΔΘΛΠΣΦΨΩ∞ƒ∘∫∂∇√"];
        // "αβγδεθλμξπρστφψω"
        // "ΓΔΘΛΠΣΦΨΩ"
        // "∇√∞∘∫"
        // "⏮⏪⏴⏺⏹⏸⏵⏩⏭"
        // "📷📹📽🕨🕪🖮"
        // "☀☁☂☃⇦⇧⇨⇩"
        // "♡♥"


      // 4 for highest quality. (6 hour run)
      downCount = 0;
      cellSize = (64 * Math.pow(2, downCount)) | 0;
      texSize = (1024 * Math.pow(2, downCount)) | 0;

      tileCount = (texSize / cellSize) | 0;
      bufferF = new Float32Array(texSize * texSize);
      widthF = texSize;
      heightF = texSize;
      var myImageData;
      var newImg;
      function createTextCanvas(color, font) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var fontStrA = 'bold ' + ((cellSize * 0.9218) + 'px ') + (font || 'Helvetica');
        var fontStrB = 'bold ' + ((cellSize * 0.78125) + 'px ') + (font || 'Noto mono');
        var fontStrC = '' + ((cellSize - 14) + 'px ') + (font || 'Symbola');
        var fontStrD = '' + ((cellSize - 14) + 'px ') + (font || 'Apple Symbols');
        canvas.width = texSize;
        canvas.height = texSize;
        canvas.style.backgroundColor = 'rgba(100, 40, 60, 1.0)';
        ctx.fillRect(0, 0, texSize, texSize);
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.fillRect((x+1)*cellSize-1,0,1,canvas.width);
            ctx.fillRect(0, (y+1)*cellSize-1, canvas.width, 1);
          }
        }
        ctx.fillStyle = color || 'white';
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.font = fontStrB;
            var text = String.fromCharCode(x + y * tileCount)
            if (y <= 1) text = symbols[y][x];
            if ((y==8) || (y==9)) text = symbols[y-6][x];
            if ((y==1) && (x==13)) ctx.font = fontStrD;
            if ((y==1) && (x==14)) text = "🕨";
            if ((y==1) && (x==15)) text = "🕪";
            var xoff = cellSize * 0.2656 //17;
            var posx = xoff + x * cellSize;
            var posy = y * cellSize + cellSize / 2 + cellSize / 3.75;
            if ((y==1) && (x<10)) {
              ctx.font = fontStrA;
              posy += cellSize * 0.0625;
              if (x == 4) posy -= cellSize * 0.09375;
            }
            if ((y==0) && (x<9)) {
              ctx.font = fontStrC;
              posy -= cellSize * 0.046875;
            }
            mw = ctx.measureText(text).width;
            if (y <= 1) posx = (cellSize-mw) / 2 + x * cellSize;  // Center symbols
            ctx.fillText(text, posx, posy);
          }
        }

        myImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        for (var y = 0; y < tileCount; y++) {
          console.log("Row " + y);
          for (var x = 0; x < tileCount; x++) {
            console.log("Col " + x);
            var borderPixels = FindBorderPixels(myImageData, x, y);
            FillDistance(myImageData, borderPixels, x, y);
          }
        }

        canvas.width = texSize >> downCount;
        canvas.height = texSize >> downCount;
        newImg = myImageData;
        // Calc gradients from floating point distances
        for (var y = 0; y < newImg.height; y++) {
          for (var x = 0; x < newImg.width; x++) {
            var grad = CalcGradF(x, y);
            var gradScale = cellSize * (254.0/256.0);  // Don't go so far that we clamp. Important thing is good directionality.
            var gradX = (grad[0] * gradScale) | 0;
            var gradY = (grad[1] * gradScale) | 0;
            // gradX /= 2;
            // gradY /= 2;
            gradX += 128;
            gradY += 128;
            gradX = Math.min(255, Math.max(0, gradX));
            gradY = Math.min(255, Math.max(0, gradY));
            SetPixelG(newImg, x, y, gradX);
            SetPixelB(newImg, x, y, gradY);
          }
        }
        for (var i = 0; i < downCount; i++) {
          DownSampleF();
          newImg = DownSample(newImg, ctx);
        }
        CopyInToA(newImg);

        ctx.putImageData(myImageData, 0, 0);
        ctx.putImageData(newImg, 0, 0);
        
        return canvas;
      }

      function IsBorderPixel(imageData, x, y) {
        var pix00 = GetPixelRTile(imageData, x, y, x, y)
        var pixP0 = GetPixelRTile(imageData, x, y, x + 1, y)
        var pixN0 = GetPixelRTile(imageData, x, y, x - 1, y)
        var pix0P = GetPixelRTile(imageData, x, y, x, y + 1)
        var pix0N = GetPixelRTile(imageData, x, y, x, y - 1)
        var on = pix00 >= 128;
        if ((pixP0 >= 128) != on) return true;
        if ((pixN0 >= 128) != on) return true;
        if ((pix0P >= 128) != on) return true;
        if ((pix0N >= 128) != on) return true;
        return false;
      }
      function FindBorderPixels(imageData, tx, ty) {
        var borderPixels = new Set();
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var posx = tx * cellSize + dx;
            var posy = ty * cellSize + dy;
            var border = IsBorderPixel(imageData, posx, posy);
            if (border) borderPixels.add((posx + posy * imageData.width) | 0)
          }
        }
        return borderPixels;
      }
      function FillDistance(imageData, borderPixels, tx, ty) {
        // Clear cell to max value.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            SetPixelF(pixx, pixy, cellSize * cellSize);
          }
        }
        // For every border pixel, draw a cone of distance from it. Only draw if smaller than existing
        // pixels so we get minimum distance everywhere.
        for (let pixel of borderPixels) {
          var posx = (pixel % imageData.width) | 0;
          var posy = (pixel / imageData.width) | 0;
          //SetPixelB(imageData, posx, posy, 255);
          var lightPixel = GetPixelR(imageData, posx, posy) >= 128;
          if (lightPixel) {
            for (var dy = 0; dy < cellSize; dy++) {
              var pixy = ty * cellSize + dy;
              var rindex = ((pixy*(imageData.width*4)) + (tx * cellSize*4)) + 0;
              for (var dx = 0; dx < cellSize; dx++) {
                var pixx = tx * cellSize + dx;
                // var currentLight = GetPixelR(imageData, pixx, pixy) >= 128;
                var currentLight = imageData.data[rindex] >= 128;
                rindex += 4;
                if (currentLight != lightPixel) {
                  var distSquared = (posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy);
                  // distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                  var findex = pixy*widthF + pixx;
                  var current = bufferF[findex];
                  // var current = GetPixelF(pixx, pixy);
                  if (distSquared < current) {
                    bufferF[findex] = distSquared;
                    // SetPixelF(pixx, pixy, distSquared);
                  }
                }
              }
            }
          }
          if (!lightPixel) {
            for (var dy = 0; dy < cellSize; dy++) {
              var pixy = ty * cellSize + dy;
              var rindex = ((pixy*(imageData.width*4)) + (tx * cellSize*4)) + 0;
              for (var dx = 0; dx < cellSize; dx++) {
                var pixx = tx * cellSize + dx;
                // var currentLight = GetPixelR(imageData, pixx, pixy) >= 128;
                var currentLight = imageData.data[rindex] >= 128;
                rindex += 4;
                if (currentLight != lightPixel) {
                  var distSquared = (posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy);
                  // distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                  var findex = pixy*widthF + pixx;
                  var current = bufferF[findex];
                  // var current = GetPixelF(pixx, pixy);
                  if (distSquared < current) {
                    bufferF[findex] = distSquared;
                    // SetPixelF(pixx, pixy, distSquared);
                  }
                }
              }
            }
          }
        }
        var scaler = 1.0 / (Math.pow(2, downCount))
        // Negate inside of letter for signed distance function.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            var currentSign = GetPixelR(imageData, pixx, pixy) >= 128 ? -1 : 1;
            var current = GetPixelF(pixx , pixy);
            current = Math.sqrt(current) - 0.5;  // Make edge of bitmap the zero crossing.
            current *= scaler;
            if (currentSign == -1) {
              SetPixelF(pixx, pixy, -current);
            } else {
              SetPixelF(pixx, pixy, current);
            }
          }
        }
      }

      function DownSample(imageData, ctx) {
        var w2 = (imageData.width / 2) | 0;
        var h2 = (imageData.height / 2) | 0;
        // var buf2 = new Uint8ClampedArray(w2 * h2);
        var buf2 = ctx.createImageData(w2, h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelR(imageData, x * 2, y * 2);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelR(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelR(buf2, x, y, f0 | 0);

            f0 = GetPixelG(imageData, x * 2, y * 2);
            f0 += GetPixelG(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelG(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelG(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelG(buf2, x, y, f0 | 0);

            f0 = GetPixelB(imageData, x * 2, y * 2);
            f0 += GetPixelB(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelB(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelB(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelB(buf2, x, y, f0 | 0);

            SetPixelA(buf2,x,y,255);
          }
        }
        return buf2;
      }
      function DownSampleF() {
        var w2 = (widthF / 2) | 0;
        var h2 = (heightF / 2) | 0;
        var buf2 = new Float32Array(w2 * h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelF(x * 2, y * 2);
            f0 += GetPixelF(x * 2 + 1, y * 2);
            f0 += GetPixelF(x * 2, y * 2 + 1);
            f0 += GetPixelF(x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            buf2[y*w2 + x] = f0;
          }
        }
        bufferF = buf2;
        widthF = w2;
        heightF = h2;
      }
      function CopyInToA(imageData) {
        for (var y = 0; y < heightF; y++) {
          for (var x = 0; x < widthF; x++) {
            var pix = GetPixelF(x, y);
            pix *= 4.0;
            pix = pix | 0;
            pix += 128;
            pix = Math.min(255, Math.max(0, pix));
            SetPixelA(imageData, x, y, pix);
          }
        }
      }

      function CalcGradF(x, y) {
        var pix00 = GetPixelFTile(x, y, x, y)
        var pixP0 = GetPixelFTile(x, y, x + 1, y)
        var pixN0 = GetPixelFTile(x, y, x - 1, y)
        var pix0P = GetPixelFTile(x, y, x, y + 1)
        var pix0N = GetPixelFTile(x, y, x, y - 1)
        var gradX = 0;
        var gradY = 0;
        gradX = pixN0 - pixP0;
        gradY = pix0N - pix0P;
        return [-gradX, -gradY];
      }
      function InRange(imageData, x, y) {
        if (x < 0) return false;
        if (y < 0) return false;
        if (x >= imageData.width) return false;
        if (y >= imageData.height) return false;
        return true;
      }
      function GetPixelR(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }
      function GetPixelG(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 1];
      }
      function GetPixelB(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 2];
      }
      function SetPixelR(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 0] = pix;
      }
      function SetPixelG(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 1] = pix;
      }
      function SetPixelB(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 2] = pix;
      }
      function SetPixelA(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 3] = pix;
      }
      function SetPixelF(x, y, pix) {
        bufferF[y*widthF + x] = pix;
      }
      function GetPixelF(x, y) {
        if (x < 0) return 0.0;
        if (y < 0) return 0.0;
        if (x >= widthF) return 0.0;
        if (y >= heightF) return 0.0;
        return bufferF[y*widthF + x];
      }
      function GetPixelFTile(tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return bufferF[y*widthF + x];
      }
      function GetPixelRTile(imageData, tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }

      function GenChar() {
        canvas = createTextCanvas('white', undefined);
        document.body.appendChild(canvas);

        canvas.onclick = function(e) {
          e = e || window.event
          var rect = canvas.getBoundingClientRect();
          var mousex = e.clientX - rect.left;
          var mousey = e.clientY - rect.top;
          var pixG = GetPixelG(newImg, mousex, mousey);
          var pixB = GetPixelB(newImg, mousex, mousey);
          console.log('Green: ' + pixG + "   Blue: " + pixB);
        }
      }

      function autorun()
      {
        GenChar();
        document.body.style.background = "#888";
      }
      if (document.addEventListener) document.addEventListener("DOMContentLoaded", autorun, false);
      else if (document.attachEvent) document.attachEvent("onreadystatechange", autorun);
      else window.onload = autorun;
    </script>
  </body>
</html>
